ifndef::imagesdir[:imagesdir: ../images]

[[section-solution-strategy]]
== Lösungsstrategie

=== Überblick

Die Gesamtlösung besteht aus **zwei unabhängigen, aber komplementären Subsystemen**, die über eine gemeinsame Flask-REST-API kommunizieren:

[cols="1,2,2" options="header"]
|===
| Subsystem | Hauptaufgabe | Technologischer Ansatz

| **Puzzle Generator**
| Erzeugt realistische Test-Puzzles mit Kamera-Simulation
| Parametrische Geometrie + Physics-based Camera Effects

| **Puzzle Solver**
| Löst Puzzle-Bilder durch Computer Vision
| Clean Up -> Segmentation → Edge Detection → Matching → Solving
|===


=== Strategien pro Subsystem

==== Puzzle Generator

**Wichtigste Entscheidungen**:

[cols="1,2,2" options="header"]
|===
| Aspekt | Lösung | Begründung

| **Pasende Puzzle-Teile**
| `ReversedCut` wrapper invertiert Punktreihenfolge (male/female)
| Garantiert perfekte passende Puzzle-Teile

| **Piece Placement**
| Grid-basiert mit Safe Zones (40% des radius)
| Verhindert Überlappung trotz 0-360° Rotation

| **Shadow Rendering**
|
| Simuliert realistische Bilder des finalen Roboters

| **Camera Effects**
|
| Simuliert tatsächliche Verzerrungen durch die Kamera-Aufnahme

|===

==== Puzzle Solver

**Wichtigste Entscheidungen**:

[cols="2,2,2" options="header"]
|===
| Problem | Lösung | Begründung

| **Bild-Verzerrung** +
| OpenCV `undistort()` mit calibration_params.json
| Muss VOR Segmentierung erfolgen, sonst sind Konturen gekrümmt

| **Teile erkkennen** +
(Schwarz auf weißem Grund)
| Otsu-Verfahren um Puzzleteil zu erkennen
| Robuster Algorithmus um Schwellenwerte zwischen Vordergrund und Hintergrund zu erkennen.

| **Eck-Erkennung** +
(Tabs/Slots verfälschen Ecken)
| Rechteckige Bounding Box mit Snap zum nächsten Konturpunkt
| Suboptimale Lösung da es nicht nur Rechteckige Puzzles gibt. Für Rechteckige Puzzles dafür sehr zuverlässig


| **Edge Matching** +
(Passende Kanten finden)
| Kurvenkorrelation + filter auf Tab-Slot matches
| Tab-Slot filter verbessert Performance und Zuverlässigkeit

| **Puzzle-Rekonstruktion**
| Start in Ecke + Greedy Algorithmus
| Einfache Lösung und nicht zu performance intensiv, da alle Teile ≥1 flache Kante haben

|===

===== Robustheit-Strategien

[cols="1,3" options="header"]
|===
| Problem | Lösung

| **Ungleichmäßige Beleuchtung**
| Vignette-Correction in GlobalCleaner

| **Gekrümmte Edges durch Distortion**
| Barrel-Distortion Calibration vor Segmentierung

| **Ambige Matches**
| Unique Best Match Rule: pro Edge nur 1 Partner > min_score

| **Missing Corners**
| Fallback: Try all 4 corners as start position

| **Weak Matches**
| Tunable `min_score` Parameter (default 0.5, range 0.0-1.0)
|===

=== Qualitätssicherung move to 9?

==== Visualisierung auf jeder Stufe

**Strategie**: Jede Pipeline-Stufe erzeugt Outputs in `app/static/output/`

[cols="1,2,2" options="header"]
|===
| Stufe | Visualisierung | Nutzen

| Segmentation
| Teile mit transparentem Hintergrund
| Kontur-Qualität, Überlappung prüfen

| Edge Detection
| Konturen + Ecken + Kanten mit Labels
| Gewählte Eckpunkte und Kantenklassifikation prüfen

| Matching
| Side-by-Side Kantenpaare mit Bewertung
| False-Positive Identifikation

| Solution
| Grid-Layout + Rendered Assembly
| End-to-End Plausibilität
|===
