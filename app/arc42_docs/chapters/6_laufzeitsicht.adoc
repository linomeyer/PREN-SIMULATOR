ifndef::imagesdir[:imagesdir: ../images]

[[section-runtime-view]]
== Laufzeitsicht

Dieses Kapitel beschreibt die wichtigsten Ablaufszenarien des Systems zur Laufzeit. Es zeigt, wie die in Kapitel 5 beschriebenen Bausteine zusammenarbeiten, um die Hauptfunktionalitäten zu realisieren.

**Abgedeckte Szenarien:**

1. Puzzle-Generierung (Generator)
2. Puzzle-Lösung (Solver)

=== Szenario 1: Puzzle-Generierung

==== Motivation

Ein Entwickler möchte ein neues Test-Puzzle mit realistischen Kamera-Effekten generieren, um den Solver zu testen.

<<<

==== Ablauf

[plantuml, format=svg]
....
@startuml

participant User
participant "Flask" as Flask
participant "api.py" as API
participant "geometry/\npuzzle.py" as Puzzle
participant "rendering/\nrenderer.py" as Renderer
participant "simulation/\ncamera.py" as Camera

User -> Flask: POST /generate\n{seed: 420381,\ncut_types: [...],\nlayout: "2x3"}

Flask -> API: parse params

API -> Puzzle: generate()

activate Puzzle
Puzzle -> Puzzle: _assign_edge_cuts()\n(Male/Female Pairing)
Puzzle -> Puzzle: _create_piece() (6x)
Puzzle -> Puzzle: _randomize_placement()\n(Grid + Rotation)
deactivate Puzzle

Puzzle --> API: pieces

API -> Renderer: render_clean()

activate Renderer
Renderer -> Renderer: _render_shadow()
Renderer -> Renderer: _render_pieces()
deactivate Renderer

Renderer --> API: clean_image

API -> Renderer: render_solution()
Renderer --> API: solution_img

API -> Camera: apply_camera_sim()

activate Camera
Camera -> Camera: barrel_distortion()
Camera -> Camera: perspective()
Camera -> Camera: chromatic_aberration()
deactivate Camera

Camera --> API: noisy_image

API --> Flask: result

Flask --> User: JSON response\n{noisy_image,\nsolution_image,\nmetadata}

@enduml
....


==== Wichtige Schritte

1. Edge Cuts zuteilen

2. Teile generieren

3. Zufälliges platzieren

4. Sauberes Rendering

5. Rendering der Lösung

6. Verzerrtes Rendering


=== Szenario 2: Puzzle-Lösung

==== Motivation

Ein Entwickler lädt ein vom Generator erzeugtes Puzzle-Bild und möchte die automatische Lösung testen.

==== Ablauf

[plantuml, format=svg]
....
@startuml

participant User
participant "Flask\nroutes.py" as Flask
participant "preprocessing/\nglobal_cleaner" as Preproc
participant "piece_extraction/\nextractor.py" as Extractor
participant "edge_detection/\nedge_detector" as EdgeDet
participant "edge_matching/\nedge_matcher" as EdgeMatch
participant "solver/\nsolver.py" as Solver

User -> Flask: POST /upload
Flask -> Flask: save img

User -> Flask: GET /extract

Flask -> Preproc: clean()
activate Preproc
Preproc -> Preproc: undistort()
deactivate Preproc
Preproc --> Flask: cleaned

Flask -> Extractor: segment_pieces()
activate Extractor
Extractor -> Extractor: findContours()
deactivate Extractor
Extractor --> Flask: pieces

Flask --> User: JSON resp.

User -> Flask: GET /detect-edges

Flask -> EdgeDet: detect_edges()
activate EdgeDet
EdgeDet -> EdgeDet: snap corners\nextract edges\nclassify\n(flat/tab/slot)
deactivate EdgeDet
EdgeDet --> Flask: edges

Flask --> User: JSON resp.

User -> Flask: GET /solve-puzzle

Flask -> EdgeMatch: find_matches()
activate EdgeMatch
EdgeMatch -> EdgeMatch: correlation\nclass compatibility\nfind unique matches
deactivate EdgeMatch
EdgeMatch --> Flask: matches

Flask -> Solver: solve()
activate Solver
Solver -> Solver: identify_corners()\n(piece with 2 flat edges)
Solver -> Solver: try_each_corner()\nas top-left
Solver -> Solver: greedy_expand()\nvia matches
Solver -> Solver: calculate_rotations()
deactivate Solver
Solver --> Flask: solution

Flask --> User: JSON resp.\n{ grid_layout,\nplaced_pieces,\nconfidence score }

@enduml
....


==== Wichtige Schritte

1. Global Cleaning
2. Segmentierung
3. Kantenerkennung
4. Kanten-Matching
5. Puzzle lösen

